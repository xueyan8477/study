webpack
一、webpack介绍
	webpack是一个静态模块打包工具。在webpack看来，项目里所有的资源皆模块，利用资源依赖关系，把各模块之间关联起来。简单来讲，就是webpack对有依赖关系的多个模块文件进行打包处理后，生成浏览器可以直接，高效运行的资源。
	通过入口文件开始，利用递归找到直接依赖或间接依赖的所有模块，并在内部构建一个能映射出项目所需的所有模块的依赖图，并进行 webpack 打包生成一个或多个 bundle 文件

	打包用的是webpack命令，即npm webpack，从webpack4开始，把webpack拆成webpack和webpack-cli两部分，分工如下：
		webpack：负责js的打包工作
		webpack-cli：解析webpack命令，命令内部使用webpack功能
		并且webpack能解析打包各种模块规范的js代码，包括：ES6、Commonjs、AND/requirejs以及CMD/Seajs
	优点：
		1、专注处理模块化的项目，能够做到开箱即用，一步到位。
		2、可通过plugin扩展，完整好用又不失灵活
		3、使用场景不限于web开发
		4、社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展
		5、良好的开发体验
	缺点：
		只能用于采用模块化开发的项目
二、什么是loader？什么是plugin？
	loader：模块转化器，webpack将一切视为模块，但是webpack只能解析js文件，而loader作用是让webpack拥有了加载和解析非js文件的能力
	plugin：在webpack构建流程中的特定时机注入扩展逻辑，让它具有更多的灵活性。在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果。
	用法区别：
	loader在module.rules中配置，也就是说他作为模块的解析规则而存在。类型为数组，每一项都是object，里面描述了对于什么类型的文件，使用什么加载和使用的参数
	plugin在plugins中单独配置。类型为数组，每一项都是一个plugin实例，参数都通过构造函数传入。
三、有哪些常用的Loader？他们是解决什么问题的？
	file-loader:把文件输出到一个文件夹中，在代码中通过相对URL去引用输出的文件
	url-loader：和file-loader类似，但是能在文件很小的情况下以base64的方式把文件内容注入到代码中去。
	source-map-loader：加载额外的sourcemap文件，以便于断点调试
	image-loader：加载并且压缩图片文件
	babel-loader：将es6转化为es5
	css-loader：加载css，支持模块化，压缩，文件导入等特性。
	style-loader：将css代码注入到js中，通过dom操作去加载 css
	eslint-loader：通过eslint检查js代码
	svg-inline-loader：将压缩后的svg内容注入到代码中
	json-loader：加载json文件（默认包含）
	ts-loader：将ts转化为js
	awesome-ts-loader：将ts转化为js，性能优于ts-loader
	sass-loader：将 CSS 代码注入 JavaScript 中，通过 DOM 操作去加载 CSS
	postcss-loader：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀
	tslint-loader：通过 TSLint检查 TypeScript 代码
	vue-loader：加载 Vue.js 单文件组件
四、有哪些常见的 Plugin？他们是解决什么问题的？
	define-plugin：定义环境变量
	commons-chunk-plugin：提取公共代码
	terser-webpack-plugin：支持压缩es6（webpack4）
	ignore-plugin：忽略部分文件
	html-webpack-plugin：简化html文件创建（依赖于htm-loader）
	web-webpack-plugin：可以方便的为单页应用输出html，比html-webpack-plugin好用
	min-css-extract-plugin：分离样式文件，css提取问单独文件，支持按需加载
	clear-webpack-plugin：删除打包文件
	happypack：实现多线程加速编译
五：如何利用webpack来优化前端性能
	用webpack优化前端性能，是指优化webpack的输出结果，让最终打包的代码在浏览器上高效运行
	1、压缩代码，删除多余代码，注释，简化代码的写法等方式。
		用UglifyJsPlugin和ParalleUglifyPlugin压缩js文件。
		用mini-css-extract-plugin压缩css
	2、利用cdn加速，在构建过程中，将引用的静态资源路径修改为cdn上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径
	3、删除死代码。JS 用 Tree Shaking，CSS 需要使用 Purify-CSS
	4、提取公共代码。用 CommonsChunkPlugin 插件
六、分别介绍bundle，chunk，module是什么
	bundle：是由webpack打包出来的文件
	chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分隔
	module：是开发中的单个模块，在webpack中一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归出所有依赖的模块。
七、webpack的热更新原理
	热更新又称热替换，基于webpack-dev-server
	当你对代码修改并保存后，将会对代码进行重新打包，并将改动的模块发送到浏览器端。浏览器用新的模块替换掉旧的模块，趋势线局部更新而非页面整体刷新。
八、webpack的构建流程是什么
	webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程
	1、初始化参数：从配置文件和shell语句中读取与合并参数，得到最终的参数。
	2、初始化编译：用上一步得到的参数初始化complier对象，加载所有配置的插件，执行对象的run方法开始编译
	3、确定入口：根据配置中的entry找出所有的入口文件
	4、编译模块：从入口文件出发，调用所有配置的loader对模块进行编译，然后再找出该模块依赖的模块，递归执行本步骤。直到所有入口依赖的模块都经过此步骤的处理。这样就得到了每个模块被编译后的最终内容，以及它们之间的依赖关系。
	5、输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再把每个chunk转化成一个单独的文件加入到输出列表，这步是可以修改输入内容的最后机会。
	6、输出完成：根据配置确定输出的路径和文件名，把文件内容写入到文件系统。
		在以上过程中，webpack会在特定的时间点广播特定的事件，插件会监听到感兴趣的事件执行特定的代码，并且可以调用webpack的api改变输出结果。
九、如何提高webpack的构建速度
	1、多入口情况下，使用commonChunkPlugin来提取公共代码
	2、通过externals配来提取常用库
	3、通过D11plugin和D11ReferencePlugin预编译资源模块，通过D11Plugin对那些我们引用但是绝对不会修改的包进行预编译，然后再通过D11ReferencePlugin把预编译的模块加载进来。
	4、使用happypack实现多线程加速编译
	5、使用webpack-uglify-parallel来提升uglifyPlugin的压缩速度。原理上此插件采用了多核并行压缩来提升压缩速度。
	6、使用TreeShaking和Scope Hoisting来剔除多余代码
十、在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？
	可以使用enforce强制执行loader的作用顺序，pre代表在所有正常的loader之前执行，post是所有loader之后执行。

React hook

一、基本概念
1、纯函数
	一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用(不会改变入参)，这个函数就是纯函数。
2、类组件和纯函数组件
	类的写法
	class welcome extends React.Component {
		render() {
			return <h1>hello,{this.props.name}</h1>
		}
	}
	钩子的写法
	function welcome(props) {
		return <h1>hello,{props.name}</h1>
	}
3、类和函数的特点
	类是数据和逻辑的封装，组件的状态和操作方法都是封装在一起的。如果选择了类的写法，就应该把相关的状态和方法都写在同一个class里面

	函数一般只应该做一件事，就是返回一个值。如果你有多个操作，每个操作应该写成一个单独的函数。而且数据的状态应该与操作方法分离。
	根据这种理念，react函数只应该做一件事，就是返回html代码，而没有其他的功能。

	纯函数组件没有状态，没有生命周期，没有this，因存在如上特点，使得纯函数组件只能做UI展示的功能， 涉及到状态的管理与切换就不得不用到类组件或这redux， 但因为简单的页面也是用类组件，同时要继承一个React实例，使得代码会显得很重。
4、副效应
	问题：函数只能进行数据计算，那么那些不涉及数字计算的（改变状态，存储数据，生成日志）应该写在哪里呢？
	函数式编程将那些非纯函数的操作，称为副效应
5、钩子的作用
	一句话，钩子就是react函数组件的副效应解决方案，用来为函数组件引入副效应。函数组件的主体只能用来返回组件的html代码，所有其他的副效应都必须通过钩子引入
二、常见的钩子
	1、useState() 
	用于为函数组件引入状态，纯函数不能有状态，所以把状态放在钩子里面。
	参数：作用是给创建出来的的参数一个默认值
	返回值：[当前的state值,设置新值使用的函数(约定是set前缀加上状态的变量名)]
	例子如下：
import React,{useState} from 'react'
export default function CounterHook() {
	const [count, setCount] = useState(0)
	return (
		<div>
			<button onClick={() => setCount(count + 1)}>+1</button>
		</div>
	)
}
	2、useContext()
	用于在组件之间共享状态
	状态共享通常使用redux mobx dva实现，useContext是react提供的实现数据共享的api，解决props层层传递的问题
	例：现在有俩组件Navbar和messages，我们希望他们之间共享状态
	(1) React.createContext()创建Context对象
const AppContext = React.createContext();
	(2) 使用Context Provider包裹组件，给他的后代组件提供数据
<AppContext.Provide value={{username:"superawesome"}}>
	<div className="App">
		<Navbar/>
		<Messages/>
	</div>
</AppContext.Provider>
	(3) ContextProvider所有的后代组件，都可以通过useContext()钩子函数用来引入Context对象，从中获取username属性
//Navbar组件
const Navbar = () => {
	const { username } = useContext(AppContext);
	return (
		<div className="navbar">
			<p>{username}</p>
		</div>
	);
}
//Message组件
const Messages = () => {
  const { username } = useContext(AppContext)
  return (
    <div className="messages">
      <p>{username}</p>
    </div>
  )
}
	3、useReducer()
	useReducer函数可以提供类似于redux的功能
//参数1：reducer函数
//参数2：初始状态
//返回值1：状态当前值
//返回值2：发送action的dispatch函数
const [state,dispatch] = useReducer(reducer,initialState)
	计算器例子如下：
//用于计算状态的reducer函数如下：
const myReducer = (state, action) => {
	switch (action.type) {
		case ('countUp'):
			return {
				...state,
				count: state.count + 1
			}
		default:
			return state;
	}
}
//组件代码如下：
function App() {
	const [state, dispatch] = useReducer(myReducer, { count: 0 });
	return (
		<div className="App">
			<button onClick={() => dispatch({ type: 'countUp' })}>
				+1
      </button>
			<p>Count: {state.count}</p>
		</div>
	);
}
由于hooks可以提供共享状态和Reducer函数，所以他在这些方面可以取代Redux。但是，他没法提供中间件（middlWare）和时间旅行（time travel）
如果需要这个功能还是需要redux
4、useEffect
上面这些钩子，都是引入某种特定的副效应。而useEffect是通用的副效应钩子。找不到专门的副效应钩子时，就使用它。最常见的就是向服务器请求数据，以前，放在componentDidMount里面的代码，现在可以放在useEffect()。
useEffect的作用就是指定一个副效应函数，组件每渲染一次，该函数就自动执行一次。组件首次在网页dom加载后，副效应函数也会执行。
useEffect的参数是一个函数，他就是要完成的副效应。组件加载以后，react就会执行这个函数；有时候我们不希望，useEffect每次渲染的时候都执行，这时候可以指定第二个参数。使用一个数组指定副效应函数的依赖项，只有当依赖项变化时，才会重新渲染。
	useEffect(() => {
		document.title = "已完成"
	}, [prop.name])
上述例子中，useEffect的第二个参数是个数组，指定了第一个参数（副效应函数）的依赖项。只有该量发生变化时，副效应函数才会执行。
如果第二个参数是一个空数组，表明副效应函数没有任何依赖项。这时，副效应函数只会在组件加载进入dom后执行一次，后面组件重新渲染就不会执行。

useEffect的用途：
	获取数据
	事件监听或者订阅
	改变dom
	输出日志

	下面是从远程服务器获取数据的例子：
	import React, { useState, useEffect } from 'react';
	import axios from 'axios';
	function App() {
		const [data, setData] = useState({ hits: [] });
		useEffect(() => {
			const fetchData = async () => {
				const result = await axios(
					'https://hn.algolia.com/api/v1/search?query=redux',
				);
				setData(result.data);
			};
			fetchData();
		}, []);
		return (
			<ul>
				{data.hits.map(item => (
					<li key={item.objectID}>
						<a href={item.url}>{item.title}</a>
					</li>
				))}
			</ul>
		);
	}
	export default App;

	useEffect()的返回值
	副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理掉这个副效应。
	useEffect()允许返回一个函数，在组件卸载的时候，执行该函数。清理副效应。如果不需要清理副效应，组件就不会返回任何值。
	useEffect(() => {
		const subscription = props.source.subscribe();
		return () => {
			subscription.unsubscribe();
		};
	}, [props.source]);
	上面的例子中，useEffect在组件加载的时候订阅了一个事件，并且返回了一个清理函数，在组件卸载时取消订阅。
	实际使用中，由于副效应函数默认每次渲染都会执行，所以清理函数不仅会在组件卸载时候执行一次，每次副效应函数重新执行之前，也会执行一次，用来清理上一次渲染的副效应。
	useEffect()的注意点
	使用时应该注意，如果有多个副效应，应该使用多次useEffect，而不应该合并写在一起。
三、自定义钩子
自定义封装前
const Person = ({ personId }) => {
	const [loading, setLoading] = useState(true);
	const [person, setPerson] = useState({});

	useEffect(() => {
		setLoading(true);
		fetch(`https://swapi.co/api/people/${personId}/`)
			.then(response => response.json())
			.then(data => {
				setPerson(data);
				setLoading(false);
			});
	}, [personId])

	if (loading === true) {
		return <p>Loading ...</p>
	}
	return <div>
		<p>You're viewing: {person.name}</p>
		<p>Height: {person.height}</p>
		<p>Mass: {person.mass}</p>
	</div>
}
自定义封装后：
const usePerson = (personId) => {
	const [loading, setLoading] = useState(true);
	const [person, setPerson] = useState({});
	useEffect(() => {
		setLoading(true);
		fetch(`https://swapi.co/api/people/${personId}/`)
			.then(response => response.json())
			.then(data => {
				setPerson(data);
				setLoading(false);
			});
	}, [personId]);
	return [loading, person];
};
上面代码中，usePerson()就是一个自定义的 Hook。Person 组件就改用这个新的钩子，引入封装的逻辑。
const Person = ({ personId }) => {
	const [loading, person] = usePerson(personId);
	if (loading === true) {
		return <p>Loading ...</p>;
	}
	return (
		<div>
			<p>You're viewing: {person.name}</p>
			<p>Height: {person.height}</p>
			<p>Mass: {person.mass}</p>
		</div>
	);
};

immutable.js
一、为什么要使用immutable.js
	熟悉React组件生命周期的都知道：调用setState方法总是会触发render方法，从而进行vDom，re-render相关逻辑。即使你没有改变实际的值。
	比如：组件state并未被改变，但仍然会触发render。
		this.state = {count:0}
		this.setState({count:0})
	为了避免这种性能上的浪费，react出了一个shouldComponentUpdate来控制是否进行vDom和re-render相关逻辑。于是PureRenderMixin作为一种优化技巧被使用。它仅仅是浅比较对象，深层次的数据结构根本不管用。
	在js中我们可以通过deep clone来模拟immutable.js，就是每次对数据进行操作，新对数据进行deep clone出一个新数据。但是这样非常的慢
var cloneDeep = require('lodash.clonedeep');
var data = {
	id: 'data',
	author: {
		name: 'mdemo',
		github: 'https://github.com/demohi'
	}
};
var data1 = cloneDeep(data);
console.log('equal:', data1 === data); //false
data1.id = 'data1';
data1.author.name = 'demohi';
console.log(data.id);// data  
console.log(data1.id);// data1
console.log(data.author.name);//mdemo  
console.log(data1.author.name);//demohi

这时候immutablejs就派上用场了。
var map1 = Immutable.fromJS({ a: 1, b: 1, c: { b: { c: { d: { e: 7 } } } } });
var map2 = Immutable.fromJS({ a: 1, b: 1, c: { b: { c: { d: { e: 7 } } } } });
Immutable.is(map1, map2);  // true
遍历对象不再用for-in，可以这样：
Immutable.fromJS({a:1, b:2, c:3}).map(function(value, key) { /* do some thing */});

二、什么是immutable Data?
	immutable Data 就是一旦创建就不能被更改的数据。对immutable对象的任何操作（添加、删除、修改）都会返回一个新的immutable对象。
	immutable实现原理是 Persistent Data structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。
	同时为了避免deepcopy把所有节点都复制一遍带来的性能损耗，immutable使用了structural Sharing...（结构共享），即如果对象数中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。
	例子：
// immutable.js 的Map
let a2 = Immutable.fromJS({
	b: 1,
	c: {
		c1: 123
	}
});
// 对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象
let b2 = a2.set('b', 2);
console.log(a2.get('b'), b2.get('b')); // 1, 2  对象 a2 的 b 值并没有变成2。
console.log(a2 === b2); //  false
//如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。
console.log(a2.get('c') === b2.get('c')); //true

三、为什么要在React.js中使用immutable
	它是一个完全独立的库，无论基于什么框架都可以使用它。意义在于他弥补了js没有不可变数据结构的问题。
	由于是不可变的，可以放心的对对象进行任何操作。在React开发中，频繁操作state或者store，配合immutablejs快，安全，方便。
