一、nodejs简介
Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好

// 引入http模块，http是nodejs自带的模块
var http = require('http');
// 创建服务器
http.createServer((request,response)=>{
  //发送http头部
  //HTTP状态值：200,：ok
  response.writeHead(200,{'Content-type':'text/plain'});
  response.end('hello world\n')
}).listen(8888);
console.log('Server running at http://127.0.0.1:8888/')

node里存在大量的回调函数，可以处理大量的并发请求，回调函数一般作为函数的最后一个参数出现。

Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。
Node.js 几乎每一个 API 都是支持回调函数的。
Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。
Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数
二、事件驱动模型
Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。
当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。

这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作
在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数

nodejs中有多个内置事件，可以通过引入events模块，并通过实例化EventEmitter类来绑定和监听事件。
//引入events模块
var events = require('events');
//创建eventEmitter对象
var eventEmitter = new event.eventEmitter();
//绑定事件及处理程序
eventEmitter.on('eventName',eventHandler);
//触发事件
eventEmitter.emit('eventName')

Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。
许多对象都会分发事件：
  net.Server对象会在每次有新连接时触发一个事件，一个fs.readStream对象会在文件被打开的时候触发一个事件，所有这些产生事件的对象都是events.eventEmitter的实例。即：net.Server对象和fs.readStream对象都是events.eventEmitter的实例
1、EventEmitter类
events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。
EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。

当注册多个相同的事件时

var events = require('events'); 
var emitter = new events.EventEmitter(); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener1', arg1, arg2); 
}); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener2', arg1, arg2); 
}); 
emitter.emit('someEvent', 'arg1 参数', 'arg2 参数');

当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。
执行结果：
listener1 arg1 参数 arg2 参数
listener2 arg1 参数 arg2 参数
2、EventEmitter类中的方法
--addListener(event, listener)/on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数
server.on('connection', function (stream) {
  console.log('someone connected!');
});
--once(event, listener)注册一个单次监听器,监听器最多只会触发一次，触发后立刻解除该监听器
--removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器（若第二个参数为匿名函数，则监听无法用此方法移除）
--removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器
--setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量
--listeners(event)返回指定事件的监听器数组
--emit(event, [arg1], [arg2], [...])触发监听
类方法（静态方法）：返回指定事件的监听器数量
events.emitter.listenerCount(eventName) //推荐
事件
newListener该事件在添加新监听器时被触发
removeListener从指定监听器数组中删除一个监听器时触发。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引

error事件
EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。当添加新的监听器时，newListener当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。
我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃

继承EventEmitter
大多数时候我们不会直接使用EventEmitter，而是在对象中继承它。包括fs，net，http在内。只要是支持事件响应的核心模块都是eventEmitter的子类。
为什么要这样做呢？原因有两点：
首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。
其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。
三、buffer缓冲区
js语言自身只有字符串数据类型 ，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。
1、创建buffer类
Buffer.alloc(size[,fill[,encoding]])返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0

// 创建一个长度为 10、且用 0 填充的 Buffer。
const buf1 = Buffer.alloc(10);

Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据

// 创建一个长度为 10、且未初始化的 Buffer。
// 这个方法比调用 Buffer.alloc() 更快，
// 但返回的 Buffer 实例可能包含旧数据，
// 因此需要使用 fill() 或 write() 重写。
const buf3 = Buffer.allocUnsafe(10);

Buffer.allocUnsafeSlow(size)

Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）

// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。
const buf4 = Buffer.from([1, 2, 3]);

Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer
Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例
Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例


// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。
const buf5 = Buffer.from('tést');
// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。
const buf6 = Buffer.from('tést', 'latin1');
2、写入缓冲区，返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。
buf.write(string[, offset[, length]][, encoding])
string - 写入缓冲区的字符串。
offset - 缓冲区开始写入的索引值，默认为 0 。
length - 写入的字节数，默认为 buffer.length
encoding - 使用的编码。默认为 'utf8' 。
//实例
buf = Buffer.alloc(256);
len = buf.write("www.runoob.com");
console.log("写入字节数 : "+  len);
3、从缓冲区读取数据，解码缓冲区数据并使用指定的编码返回字符串
buf.toString([encoding[, start[, end]]])
encoding - 使用的编码。默认为 'utf8' 。
start - 指定开始读取的索引位置，默认为 0。
end - 结束位置，默认为缓冲区的末尾。
4、将 Buffer 转换为 JSON 对象
将nodeBuffer转化为json对象
buf.toJSON()
当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。

const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

// 输出: {"type":"Buffer","data":[1,2,3,4,5]}
console.log(json);
const copy = JSON.parse(json, (key, value) => {
// key值的顺序为，buffer，1,2,3,4,5,[1,2,3,4,5],{ type: 'Buffer', data: [ 1, 2, 3, 4, 5 ] }
// value值的顺序为，buffer，1,2,3,4,5,[1,2,3,4,5],{ type: 'Buffer', data: [ 1, 2, 3, 4, 5 ] }
  return value && value.type === 'Buffer' ?
    Buffer.from(value.data) :
    value;
});

// 输出: <Buffer 01 02 03 04 05>
console.log(copy);
小插曲：json.parse(text[,reviver])
  如果指定了reviver函数，则解析出的js值会被处理后返回。遍历顺序（从最里层的属性开始，一级一级往外，最终到达顶层，也就是解析值本身）
  5、缓冲区合并
  语法：Buffer.concat(list[, totalLength])
  list用于合并的buffer对象数组列表，totalLength - 指定合并后Buffer对象的总长度
  var buffer1 = Buffer.from(('菜鸟教程'));
  var buffer2 = Buffer.from(('www.runoob.com'));
  var buffer3 = Buffer.concat([buffer1,buffer2]);
  console.log("buffer3 内容: " + buffer3.toString());
  //buffer3 内容: 菜鸟教程www.runoob.co
  6、缓冲区比较 
  buf.compare(otherBuffer);   otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象
  var buffer1 = Buffer.from('ABC');
var buffer2 = Buffer.from('ABCD');
var result = buffer1.compare(buffer2);

if(result < 0) {
   console.log(buffer1 + " 在 " + buffer2 + "之前");
}else if(result == 0){
   console.log(buffer1 + " 与 " + buffer2 + "相同");
}else {
   console.log(buffer1 + " 在 " + buffer2 + "之后");
} //ABC在ABCD之前
 7、拷贝缓冲区
 语法：buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])
  targetBuffer - 要拷贝的 Buffer 对象。
  targetStart - 数字, 可选, 默认: 0
  sourceStart - 数字, 可选, 默认: 0
  sourceEnd - 数字, 可选, 默认: buffer.length
  
  var buf1 = Buffer.from('abcdefghijkl');
  var buf2 = Buffer.from('RUNOOB');
  //将 buf2 插入到 buf1 指定位置上
  buf2.copy(buf1, 2);
console.log(buf1.toString());//abRUNOOBijkl
8、缓冲区裁剪
buf.slice([start[, end]])
start - 数字, 可选, 默认: 0
end - 数字, 可选, 默认: buffer.length

var buffer1 = Buffer.from('runoob');
// 剪切缓冲区
var buffer2 = buffer1.slice(0,2);
console.log("buffer2 content: " + buffer2.toString()); //buffer2 content: ru
9、缓冲区长度
buf.length

var buffer = Buffer.from('www.runoob.com');
//  缓冲区长度
console.log("buffer length: " + buffer.length);
执行以上代码，输出结果为：
buffer length: 14
四：Stream（流）
Stream是一个抽象接口，node中有很多对象实现了这个接口。对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）
Stream 有四种流类型：
  Readable - 可读操作。
  Writable - 可写操作。
  Duplex - 可读可写操作.
  Transform - 操作被写入数据，然后读出结果。
所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：
  data - 当有数据可读时触发。
  end - 没有更多的数据可读时触发。
  error - 在接收和写入过程中发生错误时触发。
  finish - 所有数据已被写入到底层系统时触发。
  1、从流中读取数据
  创建 input.txt 文件，内容如下：
  菜鸟教程官网地址：www.runoob.com

    var fs = require("fs");
    var data = '';
    //创建可读流
    var readerStream = fs.createReadStream('input.txt');
    // 设置编码为 utf8。
    readerStream.setEncoding('UTF8');
    // 处理流事件 --> data, end, and error
    readerStream.on('data', function(chunk) {
      data += chunk;
    });
    readerStream.on('end',function(){
      console.log(data);
    });
    readerStream.on('error', function(err){
      console.log(err.stack);
    });
    console.log("程序执行完毕");

  2、写入流
    var fs = require("fs");
var data = '菜鸟教程官网地址：www.runoob.com';
// 创建一个可以写入的流，写入到文件 output.txt 中
var writerStream = fs.createWriteStream('output.txt');
// 使用 utf8 编码写入数据
writerStream.write(data,'UTF8');
// 标记文件末尾
writerStream.end();
// 处理流事件 --> finish、error
writerStream.on('finish', function() {
    console.log("写入完成。");
});
writerStream.on('error', function(err){
   console.log(err.stack);
});
console.log("程序执行完毕");
以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：
$ node main.js 
程序执行完毕
写入完成。
查看 output.txt 文件的内容：
$ cat output.txt 
菜鸟教程官网地址：www.runoob.com
3、管道流（可以实现大文件的复制）
设置 input.txt 文件内容如下：

菜鸟教程官网地址：www.runoob.com
管道流操作实例

创建 main.js 文件, 代码如下：

var fs = require("fs");
// 创建一个可读流
var readerStream = fs.createReadStream('input.txt');
// 创建一个可写流
var writerStream = fs.createWriteStream('output.txt');
// 管道读写操作
// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中
readerStream.pipe(writerStream);
console.log("程序执行完毕");
代码执行结果如下：

$ node main.js 
程序执行完毕
查看 output.txt 文件的内容：

$ cat output.txt 
菜鸟教程官网地址：www.runoob.com
管道流操作实例
4、链式流
链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。
接下来我们就是用管道和链式来压缩和解压文件。

创建 compress.js 文件, 代码如下：

var fs = require("fs");
var zlib = require('zlib');

// 压缩 input.txt 文件为 input.txt.gz
fs.createReadStream('input.txt')
  .pipe(zlib.createGzip())
  .pipe(fs.createWriteStream('input.txt.gz'));
  
console.log("文件压缩完成。");
代码执行结果如下：

$ node compress.js 
文件压缩完成。
执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。

接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：

var fs = require("fs");
var zlib = require('zlib');

// 解压 input.txt.gz 文件为 input.txt
fs.createReadStream('input.txt.gz')
  .pipe(zlib.createGunzip())
  .pipe(fs.createWriteStream('input.txt'));
  
console.log("文件解压完成。");
代码执行结果如下：

$ node decompress.js 
文件解压完成。
