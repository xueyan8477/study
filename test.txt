一、nodejs简介
Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好

// 引入http模块，http是nodejs自带的模块
var http = require('http');
// 创建服务器
http.createServer((request,response)=>{
  //发送http头部
  //HTTP状态值：200,：ok
  response.writeHead(200,{'Content-type':'text/plain'});
  response.end('hello world\n')
}).listen(8888);
console.log('Server running at http://127.0.0.1:8888/')

node里存在大量的回调函数，可以处理大量的并发请求，回调函数一般作为函数的最后一个参数出现。

Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。
Node.js 几乎每一个 API 都是支持回调函数的。
Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。
Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数
二、事件驱动模型
Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。
当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。

这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作
在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数

nodejs中有多个内置事件，可以通过引入events模块，并通过实例化EventEmitter类来绑定和监听事件。
//引入events模块
var events = require('events');
//创建eventEmitter对象
var eventEmitter = new event.eventEmitter();
//绑定事件及处理程序
eventEmitter.on('eventName',eventHandler);
//触发事件
eventEmitter.emit('eventName')

Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。
许多对象都会分发事件：
  net.Server对象会在每次有新连接时触发一个事件，一个fs.readStream对象会在文件被打开的时候触发一个事件，所有这些产生事件的对象都是events.eventEmitter的实例。即：net.Server对象和fs.readStream对象都是events.eventEmitter的实例
1、EventEmitter类
events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。
EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。

当注册多个相同的事件时

var events = require('events'); 
var emitter = new events.EventEmitter(); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener1', arg1, arg2); 
}); 
emitter.on('someEvent', function(arg1, arg2) { 
    console.log('listener2', arg1, arg2); 
}); 
emitter.emit('someEvent', 'arg1 参数', 'arg2 参数');

当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。
执行结果：
listener1 arg1 参数 arg2 参数
listener2 arg1 参数 arg2 参数
2、EventEmitter类中的方法
--addListener(event, listener)/on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数
server.on('connection', function (stream) {
  console.log('someone connected!');
});
--once(event, listener)注册一个单次监听器,监听器最多只会触发一次，触发后立刻解除该监听器
--removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器（若第二个参数为匿名函数，则监听无法用此方法移除）
--removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器
--setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量
--listeners(event)返回指定事件的监听器数组
--emit(event, [arg1], [arg2], [...])触发监听
类方法（静态方法）：返回指定事件的监听器数量
events.emitter.listenerCount(eventName) //推荐
事件
newListener该事件在添加新监听器时被触发
removeListener从指定监听器数组中删除一个监听器时触发。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引

error事件
EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。当添加新的监听器时，newListener当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。
我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃

继承EventEmitter
大多数时候我们不会直接使用EventEmitter，而是在对象中继承它。包括fs，net，http在内。只要是支持事件响应的核心模块都是eventEmitter的子类。
为什么要这样做呢？原因有两点：
首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。
其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。
三、buffer缓冲区
js语言自身只有字符串数据类型 ，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。
1、创建buffer类
Buffer.alloc(size[,fill[,encoding]])返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0

// 创建一个长度为 10、且用 0 填充的 Buffer。
const buf1 = Buffer.alloc(10);

Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据

// 创建一个长度为 10、且未初始化的 Buffer。
// 这个方法比调用 Buffer.alloc() 更快，
// 但返回的 Buffer 实例可能包含旧数据，
// 因此需要使用 fill() 或 write() 重写。
const buf3 = Buffer.allocUnsafe(10);

Buffer.allocUnsafeSlow(size)

Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）

// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。
const buf4 = Buffer.from([1, 2, 3]);

Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer
Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例
Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例


// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。
const buf5 = Buffer.from('tést');
// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。
const buf6 = Buffer.from('tést', 'latin1');
2、写入缓冲区，返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。
buf.write(string[, offset[, length]][, encoding])
string - 写入缓冲区的字符串。
offset - 缓冲区开始写入的索引值，默认为 0 。
length - 写入的字节数，默认为 buffer.length
encoding - 使用的编码。默认为 'utf8' 。
//实例
buf = Buffer.alloc(256);
len = buf.write("www.runoob.com");
console.log("写入字节数 : "+  len);
3、从缓冲区读取数据，解码缓冲区数据并使用指定的编码返回字符串
buf.toString([encoding[, start[, end]]])
encoding - 使用的编码。默认为 'utf8' 。
start - 指定开始读取的索引位置，默认为 0。
end - 结束位置，默认为缓冲区的末尾。
4、将 Buffer 转换为 JSON 对象
将nodeBuffer转化为json对象
buf.toJSON()
当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。

const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);

// 输出: {"type":"Buffer","data":[1,2,3,4,5]}
console.log(json);
const copy = JSON.parse(json, (key, value) => {
// key值的顺序为，buffer，1,2,3,4,5,[1,2,3,4,5],{ type: 'Buffer', data: [ 1, 2, 3, 4, 5 ] }
// value值的顺序为，buffer，1,2,3,4,5,[1,2,3,4,5],{ type: 'Buffer', data: [ 1, 2, 3, 4, 5 ] }
  return value && value.type === 'Buffer' ?
    Buffer.from(value.data) :
    value;
});

// 输出: <Buffer 01 02 03 04 05>
console.log(copy);
小插曲：json.parse(text[,reviver])
  如果指定了reviver函数，则解析出的js值会被处理后返回。遍历顺序（从最里层的属性开始，一级一级往外，最终到达顶层，也就是解析值本身）
