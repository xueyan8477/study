white-space: pre-wrap;//保留空白符序列，但正常的进行换行
word-break: break-all;//允许在单词内换行

vuex
1、介绍
    Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。将数据分发给各个组件，异步数据流，统一封装接口。
    应用场景比如：购物车、会员登录等需要跨页面，跨组件实时传递数据的地方。
2、安装vuex
npm install --save vuex
3、使用vuex
//导入vuex
import Vuex from 'vuex'
//启用vuex
Vue.use(Vuex)
//实例化对象
let store=new Vuex.Store({
	state:{}//初始化数据
	mutations:{}//同步操作方法
	actions:{}//异步操作，用于操作mutations里面的方法，如果mutations里面的方法操作量大最好写在actions里面。    
	getters:{}//有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数
})
new Vue({
  el: '#app',
  router,
  store,//挂载到vue里使用
  components: { App },
  template: '<App/>'
})

4、state：定义vuex的数据源。
state: {
	total:0,
	users: [
		{ id:1, name:"张三", age:18},
		{ id:2, name:"李四", age:20},
		{ id:3, name:"王五", age:22},
		{ id:4, name:"赵六", age:25}
	] 
}
5、页面调用
方式一：
this.$store.state.count
方式二：
使用辅助函数
	方式一：
	import { mapState } from 'vuex'
	computed:{
		...mapState(['total'])
	}
	方式二：
	import { mapState } from 'vuex'
	computed:{
		...mapState({total:"total"})
	}
	方式三：
	import { mapState } from 'vuex'
	computed:{
		...mapState({total:state=>state.total})
	}

6、mutations
同步方式的方法提交，将改变的值赋给state数据源
mutations:{
	increment(state,payload){  
		state.total = payload.count;
	}
}
this.$store.commit("increment",{count:10});
	辅助函数提交
	import { mapMutations } from 'vuex’
	methods: {
     //方式一
    ...mapMutations([
          'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`
    ]),
   	//方式二
    ...mapMutations({
         add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`
    })
  }
7、actions：异步方式的方法提交，用于操作mutions里面的方法，实际应用里面获取ajax异步数据
	actions:{
		inc(conText,payload){
			conText.commit("increment",payload);
		}
	}
	this.$store.dispatch(“increment”,{count:10});
	辅助函数提交
	import { mapActions } from 'vuex’
	methods: {
     //方式一
    ... mapActions ([
          'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`
    ]),
   //方式二
    ... mapActions ({
         add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
8、gettters ：可以认为是 store 的计算属性，类似于computed，例如对列表进行过滤并计数。
	getters:{
		getUsers(state){
		  let aUsers=state.users.filter((res)=>{
		    return res.age>18;
	  })
	  return aUsers;
	}}
	this.$store.getters.getUsers
	辅助函数
	import {mapGetters} from 'vuex’
	computed: {
	//方式一
	...mapGetters([
		'getUsers'
	]),
	//方式二
	...mapGetters({
			getUsers:'getUsers'
		})
	}
9、modules：将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter。
		const moduleA = {
		namespaced:true,//命名空间
			state: { ... },
			mutations: { ... },
			actions: { ... },
			getters: { ... }
		}
		const moduleB = {
			state: { ... },
			mutations: { ... },
			actions: { ... }
		}
		const store = new Vuex.Store({
			modules: {
				a: moduleA,
				b: moduleB
			}
		})
		store.state.a // -> moduleA 的状态
		store.state.b // -> moduleB 的状态

vue-router路由
	//安装最新版本
	npm install --save vue-router
	//安装指定版本
	npm install --save vue-router@3.0.3

1、建立一个router.js文件，代码如下：

	import Vue from 'vue';
	import Router from 'vue-router';//引用路由
	import HomePage from './pages/index';

	Vue.use(Router);//装载路由

	//路由实例化
	let router=new Router({
	mode:"hash", //1、hash哈希：有#号。2、history历史：没有#号
	base: process.env.BASE_URL,//自动获取根目录路径
	routes:[
		{
				path:"/",
				name:"index",
				component:HomePage
		},
		{
			path:'/news',
			name:"news",
			component:()=>import("./pages/news")//路由懒加载
		},
  ]
});

export default router;

main.js里面的代码

import router from './router'
new Vue({
  router,
  render: h => h(App)
}).$mount('#app')

App.vue里面的代码

<template>
  <div>
    <router-view/>
  </div>
</template>

2、动态路由
routes:[
	{
		path: '/news/:id',
		name: 'news',
		component: () => import('./views/News.vue'),
	}，
]
<router-link to=“/news/10">新闻页面</router-link>

动态路由与接收参数

路由跳转方式一：
<router-link to=“/about">About</router-link>
路由跳转方式二：
this.$router.push({path:"/about"})
push进入跳转历史记录
路由跳转方式三：
this.$router.replace({path:"/about"})
replace不进入跳转历史记录

路由传参方式一：
<router-link to="/about?id=10">About</router-link>
路由传参方式二：
this.$router.push({name:"about",params:{id:10}})
params：参数不显示url地址上
路由传参方式三（推荐）：
this.$router.push({path:"/about",query:{id:10}})
query：参数显示在地址上

接收参数方式一：
this.$route.params.id
接收参数方式二（推荐）：
this.$route.query.id
返回上一级：
this.$router.go(-1)

3、主路由与子路由（路由嵌套）
let a = {
	path: "/goods",
	component: () => import("./views/goods.vue"),
	redirect: "/goods/info",//页面重定向
	children: [//子路由
		{
			path: "info",
			component: () => import("./views/goods_info.vue")
		},
		{
			path: "/user/profile",
			component: () => import("./user/profile.vue"),
			meta: { title: '个人资料', auth: true }
		}
	]
}
//auth:true表示这个页面需要进行会员认证，auth就是一个标识。

4、路由守卫
// beforeEach：全局前置守卫

const router = new VueRouter({})

router.beforeEach(function (to, from, next) {
	if (to.meta.auth) {
		if (Boolean(store.state.isLogin) == true) {//已登录     
			next();
		} else {//未登录      
			next({ "/login/index"});
		}
	} else {
		next()
	}
});

// beforeEnter：路由独享的守卫(路由内钩子)
const router = new VueRouter({
	routes: [
		{
			path: '/foo',
			component: Foo,
			beforeEnter: (to, from, next) => { }
		}
	]
})

// 组件内的守卫（组件内钩子）
beforeRouteEnter (to, from, next) {
	// 在渲染该组件的对应路由被 confirm 前调用 
	// 不！能！获取组件实例 `this` 
	// 因为当守卫执行前，组件实例还没被创建 
},
beforeRouteUpdate (to, from, next) {
	// 在当前路由改变，但是该组件被复用时调用
	 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， 
	// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
	 // 可以访问组件实例 `this` 
}, 
beforeRouteLeave (to, from, next) {
	// 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this`
}
应用场景
组件内的守卫(组件内钩子)在实际的开发过程中使用较少, 在实际的项目中beforeRouteLeave还算有用, 使用场景分别为一下三类情况:
(一) 清除当前组件中的定时器
当一个组件中有一个定时器时, 在路由进行切换的时候, 可使用beforeRouteLeave将定时器进行清楚, 以免占用内存（可以用destroyed生命周期钩子函数代替）:
beforeRouteLeave (to, from, next) {
 window.clearInterval(this.timer) //清楚定时器
 next()
}
(二) 当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转
如果页面内有重要的信息需要用户保存后才能进行跳转, 或者有弹出框的情况. 应该阻止用户跳转。
beforeRouteLeave(to, from, next) {
	if (this.isShow) {
		alert('必须关闭弹窗才能跳转页面');
		next(false);
	} else {
		next();
	}
}
(三) 保存相关内容到Vuex中或Session中
当用户需要跳转页面时, 可以将公用的信息保存到session或Vuex中（可以用destroyed生命周期钩子函数代替）。
beforeRouteLeave (to, from, next) {
  localStorage.setItem(name, content); //保存到localStorage中
  next()
}

history与hash模式的区别
hash模式：路由地址带#号。适合做后台管理系统
history模式：路由地址不带#号。适合做前端宣传页面。但是history模式有个问题就是刷新页面会出现404错误，解决方法需要配置服务器。
apache解决方案：
在根目录下新建.htaccess文件，内容如下：
<IfModule mod_rewrite.c> 
Options Indexes FollowSymLinks ExecCGI 
RewriteEngine On  
RewriteBase  /  
RewriteRule ^index\.html$ - [L]  
RewriteCond %{REQUEST_FILENAME} !-f  
RewriteCond %{REQUEST_FILENAME} !-d  
RewriteRule . /index.html [L]    
</IfModule>

nginx解决方案：
location  / {
	try_files $uri $uri/ /index.html;
}

三、开发环境配置
1、使用vue-cli3.0初始化vue
安装vue脚手架
npm install -g @vue/cli
卸载vue脚手架
npm uninstall vue-cli -g 
查看版本号
vue -V
帮助创建项目
vue --help
创建项目
vue create 项目名称
安装第三方插件
vue add axios
2、运行生成环境的文件
	1、安装serve服务器
	npm install -g serve
	2、运行方式一：
	serve -s dist
	运行方式二：
	cd dist
	serve
3、.env配置全局变量和区分开发者环境和生产环境
	全局变量
	在根目录下面创建.env文件
	内容：
	VUE_APP_URL=http://vueshop.glbuys.com
	注意命名规范：必须VUE_APP_开头
	开发者全局变量
	在根目录下创建.env.development文件
	内容
	VUE_APP_URL="http://vueshop.glbuys.com/api"

	生产环境全局变量
	在根目录下创建.env.production文件
	内容
	VUE_APP_URL="https://vueshop.glbuys.com/api"
	读取值：
	process.env.VUE_APP_URL
4、vue.config.js的配置
	根目录建立vue.config.js
	在module.exports={}里面配置
	1、配置根目录
	publicPath:'/’
	2、构建输出目录
	outputDir:'dist'
	3、 静态资源目录（js,css,image）
	assetsDir:"assets"
	4、是否开启eslint检测
	lintOnSave:false //false不开启，有效值：true || false
	productionSourceMap: false,//生成环境下面开启sourceMap支持断点调试

	服务器配置：
	devServer:{
	open:false, //是否启动打开浏览器
	host:"localhost",//主机，0.0.0.0支持局域网地址，可以用真机测试
	port:8080, //端口
	https:false,//是否启动https
	//配置跨域代理
	proxy:{
				"/api":{
				target:"http://vueshop.glbuys.com/api",
				changeOrigin:true,
				pathRewrite:{
						'^/api':""
				}
				}
		}
	}
	configureWebpack:{
	devtool: 'source-map' //配置开发者环境的sourceMap用于断点调试
}
四、eslint的配置
在package.json里面添加
"eslintConfig": {
    "root": true, //此项是用来告诉eslint找当前配置文件不能往父级查找
    "env": {
      "node": true //此项指定环境的全局变量，下面的配置指定为node环境
    },
    "extends": [// 此项是用来配置vue.js风格，就是说写代码的时候要规范的写
      "plugin:vue/essential",
      "eslint:recommended"
    ],
    "rules": {//规则配置写在这里
      "semi": ["error", "always"],
      "no-plusplus": ["error", { "allowForLoopAfterthoughts": true }]
    },
    "parserOptions": {
      "parser": "babel-eslint"//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析    }

最常用的两个命令：
/*eslint-disable*/ 禁用eslint检测
/*eslint-enable*/ 开启eslint检测

五：自定义封装组件
注册组件
export default{
	 install(Vue){
		 Vue.component("my-button",Button);
	}
}

使用组件
import Vue from 'vue';
import Button from '../components/button’
Vue.use(Button)

1、axios的介绍
	axios是一款基于promise封装的库，可以运行在浏览器端和node环境中。
	1、get请求
	2、post请求
	3、使用URLSearchParams或qs做post提交处理
	3、图片上传

2、使用URLSearchParams兼容IE
	1、安装url-search-params-polyfill
	npm install url-search-params-polyfill --save
	2、入口页面导入url-search-params-polyfill
	import 'url-search-params-polyfill';

3、fetch的使用
安装:npm install whatwg-fetch --save
引入：import fetch from 'whatwg-fetch'
	1、get请求
	2、post请求
	3、使用URLSearchParams或qs做post提交处理
	3、图片上传

	fetch的get使用
	fetch("/api/v1/news",{
   method:"get"
	}).then((res)=>{
			return res.json();
	}).then(res=>{
			this.newsList=res.data;
	});

	fetch的post使用
	fetch("/proxy/home/user/pwdlogin?token=1ec949a15fb709370f",{
		method:"post",
			headers:{
						'Content-Type':"application/x-www-form-urlencoded"
				},
			body:"cellphone="+encodeURIComponent(this.username)+"&password="+encodeURIComponent(this.password)+""
			}).then(res=>res.json()).then(res=>{
			console.log(res);
})

fetch的文件上传

let data=new FormData();
data.append("headfile",this.$refs["head"].files[0]);
fetch("/proxy/user/myinfo/formdatahead?token=1ec949a15fb709370f",{
       method:"post",
        body:data
}).then(res=>res.json()).then(res=>{
       console.log(res);
});

3、vue-i18n国际化

安装vue-i18n
npm install --save vue-i18n

使用vue-i18n
main.js里面
import VueI18n from 'vue-i18n'
Vue.use(VueI18n)
const i18n = new VueI18n({
  locale: 'cn',
  messages:{
    'cn': require('./common/lang/cn.js'),
    'en': require('./common/lang/en.js')
  }
})

new Vue({
  el: '#app',
  i18n,
  router,
  components: { App },
  template: '<App/>'
})

app.vue里面
<template>
<div>
  <div>{{ $t("sidebar.MyWallet") }}</div>
  <button @click="tag()">切换</button>
</div>
</template>

export default {
  methods:{
    tag () {
      if (this.$i18n.locale === 'en') {
          this.$i18n.locale = 'cn'
      } else {
          this.$i18n.locale = 'en'
      }
    }
  }
serviceWorker介绍
serviceWorker:service worker是在后台运行的一个线程，可以用来处理离线缓存、消息推送、后台自动更新等任务。
serviceWorker.js就是为react项目注册了一个service worker，用来做资源的缓存，这样你下次访问时，就可以更快的获取资源。而且因为资源被缓存，所以即使在离线的情况下也可以访问应用（此时使用的资源是之前缓存的资源）。
注意，serviceWorker只在生产环境中生效（process.env.NODE_ENV === ‘production’）

noopener noreferrer
<a href="https://reactjs.org" target="_blank" rel="noopener noreferrer">Learn React</a>
rel ="noopener"一般都是搭配 target="_blank"同时使用，因为 target="_blank" 也是一个安全漏洞：新的页面可以通过 window.opener 访问您的窗口对象，并且它可以使用 window.opener.location = newURL 将您的页面导航至不同的网址。新页面将与您的页面在同一个进程上运行，如果新页面正在执行开销极大的 JavaScript，您的页面性能可能会受影响。
noreferrer 属性则是为了兼容旧版本的浏览器，功能是一样的。

1、什么是jsx
JSX 是 JavaScript 的一种语法扩展，并拥有 JavaScript 的全部功能。
JSX 生产 React "元素"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它，利用JSX实现虚拟DOM。
jsx语法：
var React = require('react');
var ReactDOM = require('react-dom');
class Index extends React.Component {
  render() {
    var name = '张三';
    return (
      <div>
        Hello {name}! {/*主要是大括号*/}
      </div>
    );
  }
}
ReactDOM.render(<Index />, document.getElementById("app"));

让jsx支持内容输入html标签
var html = "<span style='color:#FF0000'>jack&nbsp;lee</span>";
<div dangerouslySetInnerHTML={{ __html: html }}></div>

ref的使用
<div ref="goods">潮流女装</div>

componentDidMount(){
  //获取方法一：
  console.log(this.refs.goods.innerHTML)
  //获取方法二：
  console.log(this.refs['goods'].innerHTML)
}

虚拟dom
var oBtn = ReactDOM.findDOMNode(document.getElementById("refsBtn"));
虚拟DOM的原理（面试题）
虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，将真实的dom转化成json对象，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能
react diff原理（面试题）
一个diff函数有两个参数一个是真实DOM，一个是虚拟DOM，使用递归对：组件，文本节点，非文本DOM节点，属性做比较，如果相同不更新，如果不相同则更新。

对比子节点：子节点和之前的不同，子节点是一个数组，它们可能改变了顺序，或者数量有所变化，我们很难确定要和虚拟DOM哪一个做对比。所以我们要给他设置一个key，如果有key使用key查找子节点的值（性能高），如果没有key则按照dom类型查找（性能低）。


条件渲染

三元表达式判断：
{ this.state.bShow ? <div>三元表达式判断</div> : '' }
<button type="button" onClick={this.setShow.bind(this)}>点击显示隐藏</button>

setShow(){
  this.setState({ bShow: !this.state.bShow });
}

&& 判断(面试题) ：判断的时候去掉三元表达式的否则。

{ this.state.bShow && <div>三元表达式判断</div> }
<button type="button" onClick={this.setShow.bind(this)}>点击显示隐藏</button>

setShow(){
  this.setState({ bShow: !this.state.bShow });
}

Map渲染数据
aGoods: [
  { id: 1, title: "潮流女装" },
  { id: 2, title: "品牌男装" },
  { id: 3, title: "手机电脑" }]

<ul>
{
  this.state.aGoods.map((item, index) => {
    return (
      <li key={index}>{item.title}</li>
    )
  })
}
</ul>


组件
main.js里面的代码：

import React from 'react';
import HeaderComponent from './heade';
export default class MainComponent extends React.Component {
  render() {
    return (
      <div>
        <HeaderComponent title='首页导航' />{/*给子组件传值*/}
        <div>我是MainComponent</div>
      </div>
    )
  }
}
什么是 Props？（面试题）
state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据
属性(Props)
header.js里面的代码：
import React from 'react';
import PropTypes from 'prop-types';//检查props类型
export default class HeaderComponent extends React.Component {
  render() {
    return (
      <div style={{width: '100%', height: '50px', background: '#0000FF', fontSize: '16px', color: '#FFFFFF’ }}>
        <div>
          { this.props.title /*用props接受*/}
        </div>
        我是HeaderComponent
      </div> 
    );
  }
}

HeaderComponent.propTypes = {
  title: PropTypes.string.isRequired //检测为字符串类型并且为必填项
}

//如果父组件没有值，给他一个默认值
HeaderComponent.defaultProps = {
  title: "默认标题"
}

在 React 中，何为 state？（面试题）
状态是 React 组件的核心，是数据的来源，必须尽可能简单。基本上状态是确定组件呈现和行为的对象。与props 不同，它们是可变的，并创建动态和交互式组件。可以通过 this.state访问它们。

状态(State)
//构造方法
constructor(props){
  //继承父类构造方法
  super(props);
  //state相当于vue里面的data方法    
  this.state = {
    name: "张三",
    age: 30
  }
}
render(){
  return (
    <div>
      <div>姓名：{this.state.name}，年龄：{this.state.age}</div>
    </div>
  )
}

(在构造函数中)调用 super(props) 的目的是什么？(面试题)

在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 props。

setState方法的使用
setState：更新state里面的值，这是一个异步方法。
this.setState({ name: "李四", age: 20 }, () => {
  console.log(this.state.name);
});

如何更新组件的状态？（面试题）
可以用 this.setState()更新组件的状态
setState第二个参数是什么？
是回调函数

生命周期
//构造方法。创建组件时调用
constructor(){

}
//页面将要加载 16.10之后UNSAFE_componentWillMount
componentWillMount(){
  console.log("componentWillMount");
}
//页面加载完成
componentDidMount(){
  console.log("componentDidMount");
}
//在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。16.10之后UNSAFE_componentWillReceiveProps
componentWillReceiveProps(newProps){
  console.log("componentWillReceiveProps" + newProps);
}
//返回一个布尔值。false为不更新组件，true为更新，在组件接收到新的props或者state时被调用。在初始化时不被调用。可以在你确认不需要更新组件时使用。用于优化
shouldComponentUpdate(newProps, newState) {
  if (this.state.name == newState.name) {
    return false;
  } else {
    return true;
  }
}
//在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。16.10之后UNSAFE_componentWillUpdate
componentWillUpdate(nextProps, nextState) {
  console.log('componentWillUpdate!', nextProps, nextState);
}

//在组件完成更新后立即调用。在初始化时不会被调用。
componentDidUpdate(prevProps, prevState) {
  console.log('componentDidUpdate', prevProps, prevState)
}
//页面渲染，react中的核心函数
render(){
  return (<div></div>)
}

//在组件从 DOM 中移除的时候立刻被调用。（当离开页面时调用）
componentWillUnmount(){
  console.log('componentWillUnmount')
}


JSX与普通html区别
1、React 事件使用驼峰命名，而不是全部小写。

2、通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。
例如，HTML：

<button onclick="activateLasers()">
  Activate Lasers
</button>

在 React 中略有不同：
<button onClick={this.activateLasers.bind(this)}>
  Activate Lasers
</button>

事件
onMouseOver:鼠标移动元素上
onMouseOut:鼠标离开元素
onMouseMove：鼠标移动
onTouchStart：触摸开始
onTouchMove：触摸移动
onTouchEnd：触摸结束

模拟双向绑定
<input type="text" placeholder="模拟双向绑定" value={this.state.bindval} onChange={(e) => {
  this.setState({ bindval: e.target.value })
}} />

利用事件子组件给父组件传值
	原理：父组件将方法传递给子组件，子组件调用父组件传递过来的方法。

插槽
// parent.js页面代码：

import React from 'react';
import PortalsChildren from './children';
export default class ProtalsIndex extends React.Component {
  render() {
    return (<div>
      插槽页面
      <PortalsChildren>我是父级插槽页面的内容</PortalsChildren>
    </div>
    );
  }
}

// children.js页面代码：

import React from 'react';
export default class ProtalsChildren extends React.Component {
  render() {
    return (
      <div>
        插槽子页面<br />
        {this.props.children /*调用portals/index.js父级PortalsChildren组件里的内容*/}
      </div>
    );
  }
}

React.lazy()（16.6以后的版本）
lazy()方法是用来对项目代码进行分割,懒加载用的.只有当组件被加载,内部的资源才会导入。
为什么需要懒加载？
在React的项目中import导入其他组件和库都是默认在初始直接导入的,webpack等打包工具会将import导入的文件直接合并到一个大文件中,如果项目很大,打包完后初始化加载时需要加载的文件会很大,这时候就需要代码分割。

静态导入:
import { add } from './math';
console.log(add(16, 26));

动态导入:
import("./math").then(math => {
  console.log(math.add(16, 26));
});
使用了动态导入之后,webpack检测到这种语法会自动代码分割。

React.Suspense（16.6以后的版本）
Suspense的作用就是在遇到异步请求或者异步导入组件的时候等待请求和导入完成再进行渲染

lazy和suspense实现组件懒加载
//父组件index.js页面
import React, { lazy, Suspense } from 'react';
//组件懒加载
const CounterComponent = lazy(() => import("../../../components/counter"));
export default class IndexPage extends React.Component {
  constructor() {
    super();
    this.state = {
      isShowCounter: false
    };
  }
  render() {
    return (
      <div>
        {
          this.state.isShowCounter &&
          <Suspense fallback={<div>loading...</div>}>
            <CounterComponent></CounterComponent>
          </Suspense>
        }
        <button type="button" onClick={this.showCounter.bind(this)}>点击显示子组件</button>
      </div>
    )
  }
}

css内联样式
内联样式需要用json格式来定义：
<div style={{width:'100%',height:'50px',background:"#0000FF",fontSize:'16px',color:'#FFFFFF'}}></div>
外部引用需要使用className，react默认不支持class。

如果想使用传统的class来获取样式，需要下载安装react-html-attrs插件

CSS模块化
React是单页面应用，引用CSS样式默认都是全局的，这样会引起样式冲突，降低性能。

Vue里面的解决方案是使用scoped：
<style scoped></style>

react里面需要配置webpack解决
配置CSS模块化
{
  test: cssRegex,
  //exclude: cssModuleRegex,
  use: getStyleLoaders({
    importLoaders: 1,
    modules: true, //1、开启css模块化
    //[path]-[name]-[local]-[hash:base64:6]
    localIdentName: '[local]_[hash:base64:6]', //2、自动生成模块化后的名称
  }),
  exclude:[//3、排除这两个文件夹下面的css文件
    path.join(__dirname, '..', 'node_modules'),
    path.join(__dirname, '..','src/assets/css/common')
  ],
},
{
	test:/\.css$/,
	use:['style-loader','css-loader'],
	include:[//4、样式只应用到这两个文件夹下面的css文件中
		path.join(__dirname, '..', 'node_modules'),
		path.join(__dirname, '..','src/assets/css/common')
	]
},

无状态组件
无状态组件（展示组件，函数式组件）：就是一个函数没有props，没有生命周期，就是一个简单的视图函数，没有业务逻辑更纯粹的展示UI。
// 代码示例：
function NullStatus() {
  return (
    <div>无状态组件</div>
  )
}

有状态组件（容器组件，类组件）:标准使用模式此函数继承了React里面的组件和props，可以使用生命周期可以在里面写业务逻辑，可以在里面做任何事情。
// 代码示例：
class HocComponent extends React.Component {
  constructor() {
    super();
    this.state = {
      name: "张三"
    }
  };
  render() {
    return (
      <div>
        有状态组件
      </div>
    )
  }
}

高阶组件
高阶组件：其实就是高阶函数，我们定义一个函数，里面返回一个有状态组件，就是高阶组件。
高阶组件就像我们吃火锅的锅底，可以在里面加羊肉、牛肉、蔬菜等各种食物。锅底相当于业务逻辑，食物相当于UI展示，这样可以使我们的业务逻辑层和UI层分离，代码更清晰，更适合多人开发和维护。

高阶组件分为两种方式：
1、属性代理的方式
属性代理是最常见的高阶组件的使用方式。它通过做一些操作，将被包裹组件的props和新生成的props一起传递给此组件，这称之为属性代理。
2、反向继承的方式
这种方式返回的React组件继承了被传入的组件，所以它能够访问到的区域、权限更多，相比属性代理方式，它更像打入组织内部，对其进行修改。

hooks介绍和应用场景

hooks是16.8版本之后的新特性，React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。组件的最佳写法应该是函数，而不是类。
React 早就支持函数组件，下面就是一个例子

function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
但是，这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。
React Hooks 的设计目的，就是加强版函数组件，完全不使用"类"，就能写出一个全功能的组件。
Hooks可以让无状态组件实现有状态组件的部分功能，比如设置state，使用钩子函数：componentDidMount、componentDidUpdate、componentWillUnmount。

import React,{useState,useEffect} from 'react'
export default function Hooks() {
	const [title,setTitle]=useState("首页");
	function changeTitle(){
		setTitle("hooks展示")
}

import React, { useState, useEffect } from 'react'
export default function Hooks() {
  const [title, setTitle] = useState("首页");
  function changeTitle() {
    setTitle("hooks展示")
  }
  //相当于componentDidMount，componentDidUpdate和componentWillUnmount
  //每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。
  //当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。不过这种用法可能带来bug，少用。
  useEffect(() => {
    document.title = title
  }, [title]);
  return (
    <div>
      {title},<button type="button" onClick={changeTitle}>改变标题</button>
    </div>
  )
}
React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。

Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) => newState。

useReducer
// pages/reducer.js页面代码：

import React, { useReducer } from 'react';
import { counterReducer, defaultState } from '../../hooksReducer/counterReducer';
import { ReactContext } from '../../context';
import ReducerComponent from './reducerComponent';
let iCount = 0;

export default function HooksReducer() {
  const [state, dispatch] = useReducer(counterReducer, defaultState);
  // console.log(state);
  return (
    <div>
      <ReactContext.Provider value={{ state, dispatch }}>
        <ReducerComponent></ReducerComponent>
      </ReactContext.Provider>
          计数器：
      <button type="button" onClick={() => { dispatch({ type: "dec", data: { count: --iCount } }) }}>-</button>{state.count}<button type="button" onClick={() => { dispatch({ type: "inc", data: { count: ++iCount } }) }}>+</button>
    </div>
  )
}

// context/index.js页面代码：
import React from "react";
// 创建上下文,解决多个组件共享传值，跨组件的问题
export const ReactContext = React.createContext();
// hooksReducer / counterReducer.js页面代码

export const defaultState = {
  count: 0
};
export const counterReducer = (state = defaultState, action) => {
  switch (action.type) {
    case "dec":
      return { ...state, ...action.data };
    case "inc":
      return { ...state, ...action.data };
    default:
      return state;
  }
};
// 子组件pages/reducerComponent.js页面代码：

import React, { useContext } from 'react';
import { ReactContext } from "../../context";
export default function ReducerComponent() {
  //useContext：共享状态钩子
  const counterContext = useContext(ReactContext);
  return (
    <div>
      子组件计数器：<button type="button" onClick={() => { counterContext.dispatch({ type: "dec", data: { count: --counterContext.state.count } }) }}>-</button>{counterContext.state.count} <button type="button" onClick={() => { counterContext.dispatch({ type: "inc", data: { count: ++counterContext.state.count } }) }}>+</button>
    </div>
  )
}

React Router 
官网：https://reacttraining.com/react-router
使用React构建的单页面应用，使用路由实现页面跳转。在React中，常用的有两个包可以实现这个需求，那就是react-router和react-router-dom（router v4）。
react-router: 实现了路由的核心功能
react-router-dom: 基于react-router，加入了在浏览器运行环境下的一些功能，例如：Link组件，会渲染一个a标签，路由模式分为：BrowserRouter(history)（不带#号）和HashRouter（带#号），前者使用pushState和popstate事件构建路由，后者使用window.location.hash和hashchange事件构建路由
安装路由
npm install --save-dev react-router-dom
引入路由和配置路由
/*router.js 页面里的代码
HashRouter:有#号
