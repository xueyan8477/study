function* takeIncCount() {
  //takeLatest:不允许并发，监听dispatch里面的type
  yield takeLatest("INC", incCount);
}

React多语言国际化
import intl from 'react-intl-universal';
constructor(){
  super();
  this.state = {
    initDone: false
  }
  this.defaultLocale = "zh-CN";
  this.locales = {
    "en-US": require('../locales/en-US.json'),
    "zh-CN": require('../locales/zh-CN.json'),
  }
}
componentDidMount(){
  intl.init({
    currentLocale: "zh-CN",
    locales: this.locales
  })
    .then(() => {
      this.setState({ initDone: true });
    });
}
render() {
  return (
    <div>
      {
        this.state.initDone &&
        <div>
          {intl.get('SIMPLE')}{/*文本格式输出*/}<br />
          {intl.getHTML('SIMPLE')}{/*支持html格式输出*/}
        </div>
      }
    </div>
  );
}

Immutable
Immutable.js 介绍
Immutable.js是facebook推出的一个类库。是最流行的不可变数据结构的实现之一。
解决原生js引用类型的坑。
引用类型赋值问题：
var obj = {a:1};
var obj2 = obj;
obj2.a = 2;
console.log(obj.a);  // 2
console.log(obj2.a);  // 2
obj2的值改变了，obj的值也改变了。一般原生解决方式就是用深拷贝或是浅拷贝解决。

引用类型比较问题：
var obj = {a:1};
var obj2 = {a:1};
console.log(obj==obj2); //false
引用类型是不能直接比较的，原生方式需要把引用类型转成字符串，再做比较。

Immutable常用API 
Map：原生object转Map对象 (只会转换第一层)
var imMap=Immutable.Map({name:’zhangsan', age:18});
get：获取Map中的数据
imMap.get('name');
set：设置Map中的数据
var imSetData=imMap.set("name","danny2");
console.log(imSetData.get("name"));

fromJS：原生js转immutable对象  (深度转换，会将内部嵌套的对象和数组全部转成immutable)
var imData=Immutable.fromJS({name:'danny', age:18,children:{name:"lisi"}});
getIn：访问嵌套的 fromJS 中的值
console.log(imData.getIn(['children','name']));
setIn：设置嵌套的 fromJS 中的值
var imData=imData.setIn(['children','name'],'张三')
console.log(imData.getIn(['children','name']));
updateIn：设置嵌套的 fromJS 中的值
var result=imData.updateIn(['age'],function(x){
        //console.log(x+20);
        return x+20;
    });
    console.log(result.getIn(['age']));

List：数组的操作
var imList=Immutable.List([1,2,3,4,5,6,7,8,9]);
//count获取总数
for (var i=0;i<imList.count();i++){
      console.log(imList.get(i));
}
var imList=Immutable.List([{age:18},{age:28},{age:38}]);
//count获取总数
for (var i=0;i<imList.count();i++){
      console.log(imList.getIn([i,”age”]));
}

is：对两个对象进行比较
var obj1=Immutable.Map({a:"11",b:"2"});
var obj2=Immutable.Map({a:"11",b:"2"});
console.log(Immutable.is(obj1,obj2));
toJS：immutable对象转原生js  (深度转换，会将内部嵌套的Map,fromJS和List全部转换成原生js)
var imData=Immutable.fromJS({name:'danny', age:18,children:{name:"lisi"}});
console.log(imData.toJS());

Immutable + Redux 的开发方式 
npm install --save immutable redux-immutable
// 在index.js页面
//引入immutable，使用fromJS
import { fromJS } from 'immutable';
//引入redux-immutable，使用redux-immutable的combineReducers代替redux
的combineReducers
import { combineReducers } from 'redux-immutable';

//fromJS({count:1})用fromJS定义初始化值
function counterReducer(state = fromJS({ count: 1 }), action) {
  switch (action.type) {
    case "INC":
      //console.log(action.data.count);
      return state.updateIn(['count'], () => action.data.count);
    case "DEC":
      return state.updateIn(['count'], () => action.data.count);
    default:
      return state;
  }
}
// 用getIn读取redux里面的值：
this.props.state.getIn(['counter', 'count'])


Mobx
Mobx是一个简单、可扩展的状态管理。适合中小型项目使用，redux适合大型项目使用。
1、安装修饰器
npm install --save-dev @babel/plugin-proposal-decorators
注意：必须是--save-dev，否则安装后会找不到模块
2、安装mobx
npm install --save mobx
3、安装mobx-react
npm install --save mobx-react
package.json或是.babelrc两者二选一，不要都配置
{
  "plugins": [
    [
      "@babel/plugin-proposal-decorators",
      {
        "legacy": true
      }
    ]
  ]
}
Mobx在react中使用
// 入口文件里面的代码：
import { observable, configure } from "mobx";
import { Provider } from "mobx-react";
//开启严格模式:那么将会限制开发者只能通过 @action 来修改 state，
//这将会更有利于组织代码以及使数据流更清晰。
configure(true);
//设置初始化值
let stores = observable({
  counter: { count: 0 }
});

class Index extends React.Component {
  render() {
    return (
      <React.Fragment>
        <Provider {...stores}>
          <RouterComponent ></RouterComponent>
        </Provider>
      </React.Fragment>
    )
  };
}
// 在页面上使用Mobx获取数据和派发数据
//导入mobx
import { action } from 'mobx';
//导入mobx-react
import { observer, inject } from "mobx-react";
//使用 @inject 给组件注入其需要的 store（利用 React context 机制）；
@inject('counter')
//通过 @observer 将 React 组件转化成响应式组件，它用 mobx.autorun 包装了组件的 render 函数以确保任何组件渲染中使用的数据变化时都可以强制刷新组件：
@observer
class IndexPage extends React.Component {
  constructor(props) {
    super(props);
    this.state = {};
  } @action incCount() {
    this.props.counter.count = this.props.counter.count + 1;
  }
  @action decCount() {
    this.props.counter.count = this.props.counter.count - 1;
  }
  render() {
    return (
      <div>
        <div>计数器:<button type='button' onClick={this.decCount.bind(this)}>-      </button>{this.props.counter.count}<button type="button" onClick={this.incCount.bind(this)}>+</button></div>
        <CounterComponent></CounterComponent>
      </div >
    )
  }
}
export default IndexPage

修饰器
Decorator（修饰器/装饰器）是es6提出的语法糖，用于修改类的行为。不过目前主流浏览器都没有很好的支持，我们需要用babel来转换为浏览器能识别的语言。
npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/plugin-proposal-decorators
package.json或是.babelrc两者二选一，不要都配置
{
  "plugins": [
    [
      "@babel/plugin-proposal-decorators",
      {
        "legacy": true
      }
    ]
  ]
}

// 基础用法
@test
class MyClass { }
function test(target) {
  target.msg = '大家好'
}
console.log(MyClass.msg) //大家好
// babel转换后的代码
var _class;
let MyClass = test(_class = class MyClass { }) || _class;
function test(target) {
  target.msg = '大家好';
}
// 修饰器decorators添加参数
@testable2("你好")
class MyClass2 { }
function testable2(msg) {
  return (target) => {
    // console.log(target);
    target.msg = msg;
    target.prototype.msg = msg;
  }
}
console.log(MyClass2.msg);
console.log(MyClass2.prototype.msg);

var obj = new MyClass2();
console.log(obj.msg);
// 修饰方法
class Math {
  @log
  add(a, b) {
    return a + b
  }
}
const math = new Math();
math.add(1, 2);
function log(target, name, descriptor) {
  //descriptor是一个Object.defineProperty
  // console.log(descriptor.value);
  //接收math.add里面的参数
  descriptor.value = function (a, b) {
    console.log(a, b);
  };
  return descriptor
}

号外：JS转码与解码
escape 和 unescape
escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。

采用unicode字符集对指定的字符串除0-255以外进行编码。所有的空格符、标点符号、特殊字符以及更多有联系非ASCII字符都将被转化成%xx格式的字符编码（xx等于该字符在字符集表里面的编码的16进制数字）。比如，空格符对应的编码是%20。
escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-Z
escape()函数用于js对字符串进行编码


encodeURI 和 decodeURI
把URI字符串采用UTF-8编码格式转化成escape各式的字符串。
encodeURI不编码字符有82个：!，#，$，&，'，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-Z
encodeURI()用于整个url编码

encodeURIComponent 和 decodeURIComponent
与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。

因此，"; / ? : @ & = + $ , #"，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。把URI字符串采用UTF-8编码格式转化成escape格式的字符串。

encodeURIComponent() 用于参数的传递，参数包含特殊字符可能会造成间断。

总结
escape编码字符串
简单来说，escape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。
编码之后的效果是%XX或者%uXXXX这种形式。
其中 ASCII字母 数字 @*/+ 等字符不会被编码，其余的都会。
最关键的是，当需要对URL编码时，忘记这个方法，这个方法是针对字符串使用的，不适用于URL。

URL编码encodeURI和encodeURIComponent
对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。它们都是编码URL，唯一区别就是编码的字符范围，其中
encodeURI方法不会对下列字符编码 ASCII字母 数字 ~!@#$&*()=:/,;?+'
encodeURIComponent方法不会对下列字符编码 ASCII字母 数字 ~!*()'
所以encodeURIComponent比encodeURI编码的范围更大。
实际例子来说，encodeURIComponent会把 http:// 编码成 http%3A%2F%2F 而encodeURI却不会。

如果只是编码字符串，不和URL有半毛钱关系，那么用escape。
如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。
当需要编码URL中的参数的时候，那么encodeURIComponent是最好方法


Document.createRange(),返回一个Range对象

js之createTextRange方法
createTextRange()方法作用：
主要是用来对一些文本对象进行操作.比如你有一大段文字,都在同一个P标签内,但是你只希望通过JS改变其中的一小部分,这时就可以用createTextRange来创建Range对象操作文本，因为默认情况下文本只是文本,并不是对象,要想像操作对象那样操作文本,只能是创建为Range对象.这是要操作的文本就具有了对象的功能和特性了.
	// 获取selection对象
	var selection = window.getSelection();
	// 清空selection对象
	selection.removeAllRanges();

	// 创建一个Range实例
	var ele = document.getElementById('blogTitle')
	var range = new Range();
	range.selectNodeContents(ele);
	// selection对象设置range实例
	selection.addRange(range);
